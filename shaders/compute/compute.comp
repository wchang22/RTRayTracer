#version 450 core

layout (local_size_x = 2, local_size_y = 2, local_size_z = 1) in;
layout (rgba32f, binding = 0) uniform image2D img_output;

layout (std140, binding = 2) uniform EyeCoords {
    vec2 coord_scale;
    vec2 coord_dims;
    vec3 eye_pos;
    mat3 eye_coord_frame;
};

struct Ray {
    vec3 point;
    vec3 direction;
};

struct Sphere {
    vec3 center;
    float radius;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

struct Triangle {
    vec3 vertices[3];
};

struct Intersection {
    bool intersects;
    float distance;
    vec3 position;
};

Intersection intersects(Ray ray, Sphere sphere) {
    vec3 o = ray.point;
    vec3 d = ray.direction;

    // offset of sphere center from ray point
    vec3 l = sphere.center - o;
    // projection of l onto ray direction
    float s = dot(l, d);
    float l2 = dot(l, l);
    float r2 = sphere.radius * sphere.radius;

    // sphere is behind ray
    if (s < 0.0 && l2 > r2) {
        return Intersection(false, 0.0, vec3(0.0));
    }

    // distance from center to ray
    float m2 = l2 - s * s;

    // ray misses sphere
    if (m2 > r2) {
        return Intersection(false, 0.0, vec3(0.0));
    }

    // distance to sphere edge
    float q = sqrt(r2 - m2);

    float t;
    // ray originates outside sphere
    if (l2 > r2) {
        t = s - q;
    // ray originates inside sphere
    } else {
        t = s + q;
    }

    return Intersection(true, t, o + t * d);
}

vec3 sphere_normal(Sphere sphere, vec3 position) {
    return normalize(position - sphere.center);
}

vec3 calc_color(vec3 light_pos, vec3 frag_pos, vec3 eye_pos, Sphere sphere) {
    vec3 normal = sphere_normal(sphere, frag_pos);
    vec3 light_dir = normalize(light_pos - frag_pos);
    vec3 eye_dir = normalize(eye_pos - frag_pos);
    vec3 half_vec = normalize(light_dir + eye_dir);
    vec3 ambient = sphere.ambient;
    vec3 diffuse = sphere.diffuse * max(dot(normal, light_dir), 0.0);
    vec3 specular = sphere.specular * pow(max(dot(normal, half_vec), 0.0), 32);
    return ambient + diffuse + specular;
}

#define NUM_SPHERES 3
#define NUM_LIGHTS 3

const vec3 lights[NUM_LIGHTS] = vec3[](
    vec3(1.5, 1.5, -3.0),
    vec3(-1.5, 1.5, -3.0),
    vec3(0.0, 1.5, 1.0)
);

const Sphere spheres[NUM_SPHERES] = Sphere[] (
    Sphere(vec3(0.0, 0.0, -2.0), 1.0, vec3(0.05, 0.2, 0.05), vec3(0.2, 0.3, 0.2), vec3(0.2, 0.3, 0.2)),
    Sphere(vec3(3.0, 0.0, -2.0), 1.0, vec3(0.2, 0.05, 0.05), vec3(0.3, 0.2, 0.2), vec3(0.3, 0.2, 0.2)),
    Sphere(vec3(-3.0, 0.0, -2.0), 1.0, vec3(0.05, 0.05, 0.2), vec3(0.2, 0.2, 0.3), vec3(0.2, 0.2, 0.3))
);

void main() {
    const ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    const vec2 coords = pixel_coords - coord_dims;
    const vec2 alpha_beta = coord_scale * coords;

    vec3 ray_dir = normalize(alpha_beta.x * eye_coord_frame[0] +
                             alpha_beta.y * eye_coord_frame[1] -
                                            eye_coord_frame[2]);

    Ray ray = Ray(eye_pos, ray_dir);

    vec3 color = vec3(0.0);

    Intersection min_intersection = Intersection(false, 1.0 / 0.0, vec3(0.0));
    int min_sphere;

    for (int i = 0; i < NUM_SPHERES; i++) {
        Intersection intersection = intersects(ray, spheres[i]);
        if (intersection.intersects && intersection.distance < min_intersection.distance) {
            min_intersection = intersection;
            min_sphere = i;
        }
    }

    if (min_intersection.intersects) {
        for (int i = 0; i < NUM_LIGHTS; i++) {
            color += calc_color(lights[i], min_intersection.position, eye_pos, spheres[min_sphere]);
        }
    }

    imageStore(img_output, pixel_coords, vec4(color, 1.0));
}
