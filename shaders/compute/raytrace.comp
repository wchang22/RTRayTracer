#version 450 core

layout (local_size_x = 32, local_size_y = 24) in;
layout (rgba8, binding = 0) uniform writeonly restrict image2D img_output;

struct Ray {
    vec3 point;
    vec3 direction;
};

struct Light {
    vec4 position;
    vec4 attenuation;
};

struct Intersectable {
    vec4 data[3];
};

struct Material {
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
};

struct Intersection {
    bool intersects;
    float distance;
    vec3 position;
};

layout (std140, binding = 2) uniform EyeCoords {
    vec2 coord_scale;
    vec2 coord_dims;
    vec3 eye_pos;
    mat3 eye_coord_frame;
};

layout (std140, binding = 3) uniform NumObjects {
    int num_spheres;
    int num_triangles;
};

layout (std430, binding = 4) buffer Intersectables {
    Intersectable intersectables[];
};

layout (std430, binding = 5) buffer Materials {
    Material materials[];
};

layout (std140, binding = 6) uniform NumLights {
    int num_point_lights;
};

layout (std430, binding = 7) buffer Lights {
    Light lights[];
};

void unpack(in vec4 data_in[3], out vec3 data_out[4]) {
    data_out[0] = data_in[0].xyz;
    data_out[1] = data_in[1].xyz;
    data_out[2] = data_in[2].xyz;
    data_out[3] = vec3(data_in[0].w, data_in[1].w, data_in[2].w);
}

// Sphere intersection
Intersection intersects(Ray ray, vec3 center, float radius) {
    // offset of sphere center from ray point
    vec3 l = center - ray.point;
    // projection of l onto ray direction
    float s = dot(l, ray.direction);
    float l2 = dot(l, l);
    float r2 = radius * radius;

    // sphere is behind ray
    if (s < 0.0 && l2 > r2) {
        return Intersection(false, 0.0, vec3(0.0));
    }

    // distance from center to ray
    float m2 = l2 - s * s;

    // ray misses sphere
    if (m2 > r2) {
        return Intersection(false, 0.0, vec3(0.0));
    }

    // distance to sphere edge
    float q = sqrt(r2 - m2);

    float t;
    // ray originates outside sphere
    if (l2 > r2) {
        t = s - q;
    // ray originates inside sphere
    } else {
        t = s + q;
    }

    return Intersection(true, t, ray.point + t * ray.direction);
}

// Triangle intersection
Intersection intersects(Ray ray, vec3 vertex, vec3 normal, vec3 edge1, vec3 edge2) {
    float a = dot(-normal, ray.direction);

    if (abs(a) < 1e-5) {
        return Intersection(false, 0.0, vec3(0.0));
    }

    float f = 1.0 / a;
    vec3 s = ray.point - vertex;
    float t = f * dot(normal, s);

    if (t < 0.0) {
        return Intersection(false, 0.0, vec3(0.0));
    }

    vec3 m = cross(s, ray.direction);
    float u = f * dot(m, edge2);

    if (u < 0.0) {
        return Intersection(false, 0.0, vec3(0.0));
    }

    float v = f * dot(-m, edge1);

    if (v < 0.0 || u + v > 1.0) {
        return Intersection(false, 0.0, vec3(0.0));
    }

    return Intersection(true, t, ray.point + t * ray.direction);
}

bool intersects_object_to_light(Ray ray, float light_distance) {
    for (int i = 0; i < num_spheres; i++) {
        vec4 center_radius = intersectables[i].data[0];
        Intersection intersection = intersects(ray, center_radius.xyz, center_radius.w);
        if (intersection.intersects && intersection.distance < light_distance) {
            return true;
        }
    }
    for (int i = num_spheres; i < num_triangles + num_spheres; i++) {
        vec3 vne1e2[4];
        unpack(intersectables[i].data, vne1e2);
        Intersection intersection = intersects(ray, vne1e2[0], vne1e2[1], vne1e2[2], vne1e2[3]);
        if (intersection.intersects && intersection.distance < light_distance) {
            return true;
        }
    }
    return false;
}

bool intersects_object(Ray ray, out Intersection min_intersection, out int object_i) {
    min_intersection = Intersection(false, 1.0 / 0.0, vec3(0.0));

    for (int i = 0; i < num_spheres; i++) {
        vec4 center_radius = intersectables[i].data[0];
        Intersection intersection = intersects(ray, center_radius.xyz, center_radius.w);
        if (intersection.intersects && intersection.distance < min_intersection.distance) {
            min_intersection = intersection;
            object_i = i;
        }
    }
    for (int i = num_spheres; i < num_triangles + num_spheres; i++) {
        vec3 vne1e2[4];
        unpack(intersectables[i].data, vne1e2);
        Intersection intersection = intersects(ray, vne1e2[0], vne1e2[1], vne1e2[2], vne1e2[3]);
        if (intersection.intersects && intersection.distance < min_intersection.distance) {
            min_intersection = intersection;
            object_i = i;
        }
    }

    return min_intersection.intersects;
}

vec3 calc_light_color(Light light, float light_distance, vec3 frag_pos,
                      vec3 eye_pos, vec3 normal, Material material) {
    vec3 light_dir = normalize(light.position.xyz - frag_pos);
    vec3 eye_dir = normalize(eye_pos - frag_pos);
    vec3 half_vec = normalize(light_dir + eye_dir);
    vec3 diffuse = material.diffuse.xyz * max(dot(normal, light_dir), 0.0);
    vec3 specular = material.specular.xyz * pow(max(dot(normal, half_vec), 0.0), material.specular.w);
    return (diffuse + specular) /
            dot(light.attenuation.xyz, vec3(1.0, light_distance, light_distance * light_distance));
}

void main() {
    const int RECURSION_DEPTH = 4;

    // Get coords and put into view and perspective
    const ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    const vec2 alpha_beta = coord_scale * (pixel_coords - coord_dims + 0.5);

    // Initial ray starts from eye and shoots towards screen location
    vec3 ray_dir = normalize(alpha_beta.x * eye_coord_frame[0] +
                             alpha_beta.y * eye_coord_frame[1] -
                                            eye_coord_frame[2]);
    vec3 ray_pos = eye_pos;

    vec3 reflectivity = vec3(1.0);
    vec3 color = vec3(0.0);

    for (int i = 0; i < RECURSION_DEPTH; i++) {
        Ray ray = Ray(ray_pos, ray_dir);

        Intersection intersection;
        int object_i;

        // Find intersection
        if (!intersects_object(ray, intersection, object_i)) {
            break;
        }

        Intersectable intersectable = intersectables[object_i];
        Material material = materials[object_i];
        vec3 intersectable_normal;

        // Intersected triangle
        if (object_i >= num_spheres) {
            intersectable_normal = normalize(intersectable.data[1].xyz);
        // Intersected sphere
        } else {
            intersectable_normal = normalize(intersection.position - intersectable.data[0].xyz);
        }

        vec3 current_color = material.ambient.xyz;

        // Calculate light contribution
        for (int i = 0; i < num_point_lights; i++) {
            vec3 ray_to_light_dir = lights[i].position.xyz - intersection.position;
            float ray_to_light_distance = length(ray_to_light_dir);
            ray_to_light_dir = normalize(ray_to_light_dir);
            // Bias intersection position up a bit to prevent self-intersection
            vec3 ray_to_light_point = intersection.position + ray_to_light_dir * 1e-2;
            Ray light_ray = Ray(ray_to_light_point, ray_to_light_dir);

            // If the light ray is not blocked by any object, calculate color
            if (!intersects_object_to_light(light_ray, ray_to_light_distance)) {
                current_color += calc_light_color(lights[i], ray_to_light_distance,
                                                  intersection.position,
                                                  eye_pos, intersectable_normal, material);
            }
        }

        // Ray is now reflected off intersection point
        ray_dir = reflect(ray_dir, intersectable_normal);
        ray_pos = intersection.position + ray_dir * 1e-2;

        color += reflectivity * current_color;
        reflectivity *= material.specular.xyz;

        // If reflectivity is low, the additional colour will not have a meaningful effect
        if (length(reflectivity) < 1e-3) {
            break;
        }
    }

    imageStore(img_output, pixel_coords, vec4(color, 1.0));
}
