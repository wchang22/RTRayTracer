#version 450 core

layout (local_size_x = 32, local_size_y = 24) in;
layout (rgba8, binding = 0) uniform writeonly restrict image2D img_output;

struct Ray {
    vec3 point;
    vec3 direction;
    float length;
    int intersectable;
};

struct Light {
    vec4 position;
    vec4 attenuation;
};

struct Intersectable {
    vec4 data[3];
};

struct Material {
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
};

layout (std140, binding = 2) uniform EyeCoords {
    vec2 coord_scale;
    vec2 coord_dims;
    vec3 eye_pos;
    mat3 eye_coord_frame;
};

layout (std140, binding = 3) uniform NumObjects {
    int num_spheres;
    int num_triangles;
};

layout (std430, binding = 4) buffer Intersectables {
    Intersectable intersectables[];
};

layout (std430, binding = 5) buffer Materials {
    Material materials[];
};

layout (std140, binding = 6) uniform NumLights {
    int num_point_lights;
};

layout (std430, binding = 7) buffer Lights {
    Light lights[];
};

void unpack(in vec4 data_in[3], out vec3 data_out[4]) {
    data_out[0] = data_in[0].xyz;
    data_out[1] = data_in[1].xyz;
    data_out[2] = data_in[2].xyz;
    data_out[3] = vec3(data_in[0].w, data_in[1].w, data_in[2].w);
}

Ray create_ray(vec3 point, vec3 direction) {
    return Ray(point, direction, 1.0 / 0.0, -1);
}

// Sphere intersection
bool intersects(inout Ray ray, int intersectable, vec3 center, float radius) {
    // offset of sphere center from ray point
    vec3 l = center - ray.point;
    // projection of l onto ray direction
    float s = dot(l, ray.direction);
    float l2 = dot(l, l);
    float r2 = radius * radius;

    // sphere is behind ray
    if (s < 0.0 && l2 > r2) {
        return false;
    }

    // distance from center to ray
    float m2 = l2 - s * s;

    // ray misses sphere
    if (m2 > r2) {
        return false;
    }

    // distance to sphere edge
    float q = sqrt(r2 - m2);

    float t;
    // ray originates outside sphere
    if (l2 > r2) {
        t = s - q;
    // ray originates inside sphere
    } else {
        t = s + q;
    }

    if (t > ray.length) {
        return false;
    }

    ray.length = t;
    ray.intersectable = intersectable;
    return true;
}

// Triangle intersection
bool intersects(inout Ray ray, int intersectable, vec3 vertex, vec3 normal, vec3 edge1, vec3 edge2) {
    float a = dot(-normal, ray.direction);

    if (abs(a) < 1e-5) {
        return false;
    }

    float f = 1.0 / a;
    vec3 s = ray.point - vertex;
    float t = f * dot(normal, s);

    if (t < 0.0 || t > ray.length) {
        return false;
    }

    vec3 m = cross(s, ray.direction);
    float u = f * dot(m, edge2);

    if (u < 0.0) {
        return false;
    }

    float v = f * dot(-m, edge1);

    if (v < 0.0 || u + v > 1.0) {
        return false;
    }

    ray.length = t;
    ray.intersectable = intersectable;
    return true;
}

bool intersects_object_to_light(inout Ray light_ray, float light_distance) {
    for (int i = 0; i < num_spheres; i++) {
        vec4 center_radius = intersectables[i].data[0];
        intersects(light_ray, i, center_radius.xyz, center_radius.w);
        if (light_ray.length < light_distance) {
            return true;
        }
    }
    for (int i = num_spheres; i < num_triangles + num_spheres; i++) {
        vec3 vne1e2[4];
        unpack(intersectables[i].data, vne1e2);
        intersects(light_ray, i, vne1e2[0], vne1e2[1], vne1e2[2], vne1e2[3]);
        if (light_ray.length < light_distance) {
            return true;
        }
    }
    return false;
}

bool intersects_object(inout Ray ray) {
    for (int i = 0; i < num_spheres; i++) {
        vec4 center_radius = intersectables[i].data[0];
        intersects(ray, i, center_radius.xyz, center_radius.w);
    }
    for (int i = num_spheres; i < num_triangles + num_spheres; i++) {
        vec3 vne1e2[4];
        unpack(intersectables[i].data, vne1e2);
        intersects(ray, i, vne1e2[0], vne1e2[1], vne1e2[2], vne1e2[3]);
    }

    return ray.intersectable != -1;
}

vec3 calc_light_color(Light light, float light_distance, vec3 frag_pos,
                      vec3 eye_pos, vec3 normal, Material material) {
    vec3 light_dir = normalize(light.position.xyz - frag_pos);
    vec3 eye_dir = normalize(eye_pos - frag_pos);
    vec3 half_vec = normalize(light_dir + eye_dir);
    vec3 diffuse = material.diffuse.xyz * max(dot(normal, light_dir), 0.0);
    vec3 specular = material.specular.xyz * pow(max(dot(normal, half_vec), 0.0), material.specular.w);
    return (diffuse + specular) /
            dot(light.attenuation.xyz, vec3(1.0, light_distance, light_distance * light_distance));
}

void main() {
    const int RECURSION_DEPTH = 4;

    // Get coords and put into view and perspective
    const ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    const vec2 alpha_beta = coord_scale * (pixel_coords - coord_dims + 0.5);

    // Initial ray starts from eye and shoots towards screen location
    vec3 ray_dir = normalize(alpha_beta.x * eye_coord_frame[0] +
                             alpha_beta.y * eye_coord_frame[1] -
                                            eye_coord_frame[2]);
    vec3 ray_pos = eye_pos;

    vec3 reflectivity = vec3(1.0);
    vec3 color = vec3(0.0);

    for (int i = 0; i < RECURSION_DEPTH; i++) {
        Ray ray = create_ray(ray_pos, ray_dir);

        // Find intersection
        if (!intersects_object(ray)) {
            break;
        }

        vec3 intersection = ray.point + ray.length * ray.direction;
        Intersectable intersectable = intersectables[ray.intersectable];
        Material material = materials[ray.intersectable];
        vec3 intersectable_normal;

        // Intersected triangle
        if (ray.intersectable >= num_spheres) {
            intersectable_normal = normalize(intersectable.data[1].xyz);
        // Intersected sphere
        } else {
            intersectable_normal = normalize(intersection - intersectable.data[0].xyz);
        }

        vec3 current_color = material.ambient.xyz;

        // Calculate light contribution
        for (int i = 0; i < num_point_lights; i++) {
            vec3 ray_to_light_dir = lights[i].position.xyz - intersection;
            float ray_to_light_distance = length(ray_to_light_dir);
            ray_to_light_dir = normalize(ray_to_light_dir);
            // Bias intersection position up a bit to prevent self-intersection
            vec3 ray_to_light_point = intersection + ray_to_light_dir * 1e-2;
            Ray light_ray = create_ray(ray_to_light_point, ray_to_light_dir);

            // If the light ray is not blocked by any object, calculate color
            if (!intersects_object_to_light(light_ray, ray_to_light_distance)) {
                current_color += calc_light_color(lights[i], ray_to_light_distance,
                                                  intersection,
                                                  eye_pos, intersectable_normal, material);
            }
        }

        // Ray is now reflected off intersection point
        ray_dir = reflect(ray_dir, intersectable_normal);
        ray_pos = intersection + ray_dir * 1e-2;

        color += reflectivity * current_color;
        reflectivity *= material.specular.xyz;

        // If reflectivity is low, the additional colour will not have a meaningful effect
        if (length(reflectivity) < 1e-3) {
            break;
        }
    }

    imageStore(img_output, pixel_coords, vec4(color, 1.0));
}
