#version 450 core

layout (local_size_x = 2, local_size_y = 2, local_size_z = 1) in;
layout (rgba16f, binding = 0) uniform writeonly restrict image2D img_output;

layout (std140, binding = 2) uniform EyeCoords {
    vec2 coord_scale;
    vec2 coord_dims;
    vec3 eye_pos;
    mat3 eye_coord_frame;
};

struct Ray {
    vec3 point;
    vec3 direction;
};

struct PointLight {
    vec3 position;
    vec3 attenuation;
};

struct Intersectable {
    vec3 data[3];
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

struct Intersection {
    bool intersects;
    float distance;
    vec3 position;
};

const PointLight lights[] = {
    PointLight(vec3(1.5, 2.5, -2.0), vec3(1.0, 0.045, 0.016)),
    PointLight(vec3(-1.5, 2.5, -2.0), vec3(1.0, 0.045, 0.016)),
    PointLight(vec3(0.0, 2.5, 2.0), vec3(1.0, 0.045, 0.016))
};

const Intersectable spheres[] = {
    { { vec3(0.0, 1.0, 0.0), vec3(1.0), vec3(0.0) },
        vec3(0.01, 0.1, 0.01), vec3(0.2, 0.3, 0.2), vec3(0.4, 0.7, 0.4) },
    { { vec3(3.0, 1.0, 0.0), vec3(1.0), vec3(0.0) },
        vec3(0.1, 0.01, 0.01), vec3(0.3, 0.2, 0.2), vec3(0.7, 0.4, 0.4) },
    { { vec3(-3.0, 1.0, 0.0), vec3(1.0), vec3(0.0) },
        vec3(0.01, 0.01, 0.1), vec3(0.2, 0.2, 0.3), vec3(0.4, 0.4, 0.7) }
};

const Intersectable triangles[] = {
    { { vec3(5.0, 0.0, 5.0), vec3(5.0, 0.0, -5.0), vec3(-5.0, 0.0, -5.0)  },
        vec3(0.01), vec3(0.2), vec3(0.2) },
    { { vec3(5.0, 0.0, 5.0), vec3(-5.0, 0.0, -5.0), vec3(-5.0, 0.0, 5.0) },
        vec3(0.01), vec3(0.2), vec3(0.2) }
};

// Sphere intersection
Intersection intersects(Ray ray, vec3 center, float radius) {
    // offset of sphere center from ray point
    vec3 l = center - ray.point;
    // projection of l onto ray direction
    float s = dot(l, ray.direction);
    float l2 = dot(l, l);
    float r2 = radius * radius;

    // sphere is behind ray
    if (s < 0.0 && l2 > r2) {
        return Intersection(false, 0.0, vec3(0.0));
    }

    // distance from center to ray
    float m2 = l2 - s * s;

    // ray misses sphere
    if (m2 > r2) {
        return Intersection(false, 0.0, vec3(0.0));
    }

    // distance to sphere edge
    float q = sqrt(r2 - m2);

    float t;
    // ray originates outside sphere
    if (l2 > r2) {
        t = s - q;
    // ray originates inside sphere
    } else {
        t = s + q;
    }

    return Intersection(true, t, ray.point + t * ray.direction);
}

// Triangle intersection
Intersection intersects(Ray ray, vec3 vertices[3]) {
    const float epsilon = 1e-5;
    vec3 e1 = vertices[1] - vertices[0];
    vec3 e2 = vertices[2] - vertices[0];

    vec3 q = cross(ray.direction, e2);
    float a = dot(e1, q);

    if (abs(a) < epsilon) {
        return Intersection(false, 0.0, vec3(0.0));
    }

    float f = 1.0 / a;
    vec3 s = ray.point - vertices[0];
    float u = f * dot(s, q);

    if (u < 0.0) {
        return Intersection(false, 0.0, vec3(0.0));
    }

    vec3 r = cross(s, e1);
    float v = f * dot(ray.direction, r);

    if (v < 0.0 || u + v > 1.0) {
        return Intersection(false, 0.0, vec3(0.0));
    }

    float t = f * dot(e2, r);

    if (t < 0.0) {
        return Intersection(false, 0.0, vec3(0.0));
    }

    return Intersection(true, t, ray.point + t * ray.direction);
}

bool intersects_object_to_light(Ray ray, float light_distance) {
    for (int i = 0; i < spheres.length(); i++) {
        Intersection intersection = intersects(ray, spheres[i].data[0], spheres[i].data[1].x);
        if (intersection.intersects && intersection.distance < light_distance) {
            return true;
        }
    }
    for (int i = 0; i < triangles.length(); i++) {
        Intersection intersection = intersects(ray, triangles[i].data);
        if (intersection.intersects && intersection.distance < light_distance) {
            return true;
        }
    }
    return false;
}

bool intersects_object(Ray ray, out Intersection min_intersection, out int object_i) {
    min_intersection = Intersection(false, 1.0 / 0.0, vec3(0.0));

    for (int i = 0; i < spheres.length(); i++) {
        Intersection intersection = intersects(ray, spheres[i].data[0], spheres[i].data[1].x);
        if (intersection.intersects && intersection.distance < min_intersection.distance) {
            min_intersection = intersection;
            object_i = i;
        }
    }
    for (int i = 0; i < triangles.length(); i++) {
        Intersection intersection = intersects(ray, triangles[i].data);
        if (intersection.intersects && intersection.distance < min_intersection.distance) {
            min_intersection = intersection;
            object_i = i + spheres.length();
        }
    }

    return min_intersection.intersects;
}

// Sphere normal
vec3 normal(vec3 center, vec3 position) {
    return normalize(position - center);
}

// Triangle normal
vec3 normal(vec3 vertices[3], vec3 position) {
    vec3 e1 = vertices[1] - vertices[0];
    vec3 e2 = vertices[2] - vertices[0];
    return normalize(cross(e1, e2));
}

vec3 calc_light_color(PointLight light, float light_distance, vec3 frag_pos,
                      vec3 eye_pos, vec3 normal, Intersectable intersectable) {
    vec3 light_dir = normalize(light.position - frag_pos);
    vec3 eye_dir = normalize(eye_pos - frag_pos);
    vec3 half_vec = normalize(light_dir + eye_dir);
    vec3 diffuse = intersectable.diffuse * max(dot(normal, light_dir), 0.0);
    vec3 specular = intersectable.specular * pow(max(dot(normal, half_vec), 0.0), 32);
    return (diffuse + specular) /
            dot(light.attenuation, vec3(1.0, light_distance, light_distance * light_distance));
}

void main() {
    const int RECURSION_DEPTH = 2;

    // Get coords and put into view and perspective
    const ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    const vec2 alpha_beta = coord_scale * (pixel_coords - coord_dims + 0.5);

    // Initial ray starts from eye and shoots towards screen location
    vec3 ray_dir = normalize(alpha_beta.x * eye_coord_frame[0] +
                             alpha_beta.y * eye_coord_frame[1] -
                                            eye_coord_frame[2]);
    vec3 ray_pos = eye_pos;

    vec3 reflectivity = vec3(1.0);
    vec3 color = vec3(0.0);

    for (int i = 0; i < RECURSION_DEPTH; i++) {
        // If reflectivity is low, the additional colour will not have a meaningful effect
        if (length(reflectivity) < 1e-3) {
            break;
        }

        Ray ray = Ray(ray_pos, ray_dir);

        Intersection intersection;
        int object_i;

        // Find intersection
        if (!intersects_object(ray, intersection, object_i)) {
            continue;
        }

        Intersectable intersectable;
        vec3 intersectable_normal;

        // Intersected triangle
        if (object_i >= spheres.length()) {
            intersectable = triangles[object_i - spheres.length()];
            intersectable_normal = normal(intersectable.data, intersection.position);
        // Intersected sphere
        } else {
            intersectable = spheres[object_i];
            intersectable_normal = normal(intersectable.data[0], intersection.position);
        }

        vec3 current_color = intersectable.ambient;

        // Calculate light contribution
        for (int i = 0; i < lights.length(); i++) {
            vec3 ray_to_light_dir = lights[i].position - intersection.position;
            float ray_to_light_distance = length(ray_to_light_dir);
            ray_to_light_dir = normalize(ray_to_light_dir);
            // Bias intersection position up a bit to prevent self-intersection
            vec3 ray_to_light_point = intersection.position + ray_to_light_dir * 1e-2;
            Ray light_ray = Ray(ray_to_light_point, ray_to_light_dir);

            // If the light ray is not blocked by any object, calculate color
            if (!intersects_object_to_light(light_ray, ray_to_light_distance)) {
                current_color += calc_light_color(lights[i], ray_to_light_distance,
                                                  intersection.position,
                                                  eye_pos, intersectable_normal, intersectable);
            }
        }

        // Ray is now reflected off intersection point
        ray_dir = reflect(ray_dir, intersectable_normal);
        ray_pos = intersection.position + ray_dir * 1e-2;

        color += reflectivity * current_color;
        reflectivity *= intersectable.specular;
    }

    imageStore(img_output, pixel_coords, vec4(color, 1.0));
}
